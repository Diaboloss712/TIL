# Computer Structure

## CPU

- ALU(Arithmetic and Logic Unit) : 사칙 연산, 논리 연산 등 연산을 수행하는 장치
- 제어장치(Control Unit) : 명령어를 해석해 제어 신호라는 전기 신호를 내보내는 장치
- 레지스터(Register) : 데이터와 명령어를 처리하는 과정의 중간값을 저장하는 임시 저장장치


### 메모리와 캐시 메모리

메모리 : CPU가 읽고 해석하고 실행하는 모든 정보를 저장하는 장치, 휘발성
메인 메모리 : RAM, ROM
캐시 메모리 : 빠른 접근을 위해 CPU와 메모리 사이에 있는 저장장치
보조기억장치 : HDD, SSD 등 비휘발성 저장장치


### 메인 보드와 버스

메인보드 : 컴퓨터의 핵심 부품들을 고정하고 연결하는 기판
시스템 버스 : 컴퓨터의 핵심 부품을 연결하는 버스(주소 버스, 데이터 버스, 제어 버스)
버스 : 각 컴퓨터 부품들이 정보를 주고받는 통로


저장장치 계층 구조

레지스터 -> 캐시메모리 -> 메모리 -> 기억장치
빠름 < - > 느림
용량이 작음 < - > 용량이 큼
비쌈 < - > 저렴함


### 2진수의 수와 음수 표현법

2진수로 음수를 표현하는 방법은 다양한 방법이 있다.

1. 최상위 비트를 이용하는 방법
    5 = 0000 0000 0000 0000 0000 0000 0000 0101
    -5 = 1000 0000 0000 0000 0000 0000 0000 0101

2. 1의 보수
    보수 : 보충해주는 수
    여기에서는 어떤 수를 만들기 위해 필요한 수를 의미한다.
    n진법에는 n의 보수와 n-1의 보수가 사용

    3에 대한 10의 보수를 생각해보면 10-3 = 7
    12에 대한 10의 보수는 100 - 12 = 88
    n의 보수는 어떤 수에 대해 n의 제곱수가 되도록 만드는 수

    보수를 사용하는 이유 : 덧셈만으로 결과값을 얻기 위해(음수, 양수 관계없이)
    -23 + 31을 가정하면
    77 + 31 - 100 = 8
    위의 과정에서 십의 자리에서 백의 자리로 자릿수가 바뀌게 되는데, 이때 자리 올림이 발생하는걸 캐리 발생이라고 한다.
    캐리가 발생하면 양수, 그렇지 않으면 음수로 판별할 수 있다.

    이제 2진법으로 가정해보자
    0000 0011의 2의 보수 :
    1 0000 0000 - 0000 0011 = 1111 1101
    1111 1111 - 0000 0011 = 1111 1100 (모든 비트가 1인 수에서 3을 빼면 -3, 즉 3의 1의 보수를 알 수 있다.)

3. 2의 보수
    1의 보수에서 +0, -0이 둘다 있으며, 캐리가 발생하는지에 따라 +1을 해야하는 문제를 해결할 수 있다.
    1의 보수에서 1을 더하면 2의 보수
    예시로 몇가지 값을 더해보자.

    23 + 31
    0 000 0000 0000 0000 0000 0000 0001 0111(23)
    0 000 0000 0000 0000 0000 0000 0001 1111(31)
    0 000 0000 0000 0000 0000 0000 0011 0110(54)

    -23 + 31
    1 111 1111 1111 1111 1111 1111 1110 1001(-23)
    0 000 0000 0000 0000 0000 0000 0001 1111(31)

    1 - 0 000 0000 0000 0000 0000 0000 0000 1000(캐리 발생)

    -23 - 31
    1 111 1111 1111 1111 1111 1111 1110 1001(-23)
    1 111 1111 1111 1111 1111 1111 1110 0001(-31)
    1 - 1 111 1111 1111 1111 1111 1111 1100 1010(캐리 발생)

    1의 보수에서는 캐리의 발생에 따라 값이 달라졌지만 2의 보수에서는 처리하지 않아도 되는 결과를 확인할 수 있다.


### 소수 표현

컴퓨터에서는 이진법으로 소수점을 표기하는데 한계가 있어 부동 소수점을 사용한다.

IEEE 754는 부동 소수점의 저장 방식으로
[부호 - 지수 - 가수]
의 형태로 저장한다.

컴퓨터가 지수를 저장할 때 바이어스 값이 저장되는데,
이때 바이어스 값은 2^(k-1)-1이다. - k는 지수의 비트 수

예시로 지수를 표현하는데 10비트가 사용되었다면
바이어스는 2^9 -1 = 511


### 레지스터

1. 프로그램 카운터(명령어 포인터)
   - 메모리에서 다음으로 읽어 들일 명령어의 주소를 저장한다.
   - 일반적으로 1씩 증가하여 다음의 메모리 주소를 순차적으로 읽는다.
  
2. 명령어 레지스터
   - 메모리에서 방금 읽어 들인 명령어를 저장하는 레지스터
   - 명령어 레지스터가 읽은 명령어를 해석하여 다른 부품으로 제어 신호를 보내 작동시킨다.

3. 범용 레지스터
   - 데이터, 명령어, 주소 모두를 저장할 수 있는 자유로운 레지스터

4. 플래그 레지스터
   - 연산의 결과나 CPU 상태에 대한 부가 정보인 플래그 값을 저장하는 레지스터
   - 플래그 : CPU가 명령어를 처리하는 과정에서 반드시 참조해야 할 상태 정보를 의미하는 비트


    | 종류 | 설명 | 설명 예시 |
    | :-- | :-- | :-- | 
    | 부호 플래그 | 연산 결과의 부호 | 부호 플래그가 1이면 음수, 0이면 양수 |
    | 제로 플래그 | 연산 결과가 0인가 | 제로 플래그가 1이면 0, 0이면 0이 아님|
    | 캐리 플래그 | 연산에서 올림수나 빌림수가 발생했는가 | 1이면 발생, 0이면 아님 |
    | 오버플로우 플래그 | 오버플로우 발생했는지의 여부 | 1이면 발생, 0이면 아님 |
    | 인터럽트 플래그 | 인터럽트가 가능한가 | 1이면 가능, 0이면 불가 |
     | 슈퍼바이저 플래그 | 커널 모드인지 사용자 모드인지 | 1이면 커널, 0이면 사용자 모드 |

5. 스택 포인터
   - 스택 구현할 때 쓰던 top


### 인터럽트
   - 인터럽트 : CPU의 작업을 방해하는 신호
      - 동기 인터럽트 : CPU에 의해 발생하는 인터럽트(프로그래밍 오류, 예외)
      - 비동기 인터럽트(하드웨어 인터럽트) : 입출력장치에 의해 발생하는 인터럽트, 알림의 역할

- 하드웨어 인터럽트
  - 다른 입출력 장치가 언제 끝날지 모르기 때문에 그때까지 하던 일을 계속 하기 위해 필요
  - 과정
    1. 입출력장치가 CPU에게 인터럽트 요청 신호를 보냄
    2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전에 인터럽트 여부를 확인
    3. 인터럽트 요청을 확인 후 인터럽트 플래그를 통해 상태 확인
    4. 인터럽트가 가능하다면 지금까지의 작업을 백업
    5. 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행
    6. 인터럽트 서비스 루틴이 끝나면 백업해 둔 작업을 복구 후 실행 재개
   
  - 인터럽트 플래그로 인터럽트 요청을 판단할 수 있지만, 막을 수 없는 인터럽트가 있다. (하드웨어 고장)
  - CPU가 인터럽트를 받아들이면 인터럽트 서비스 루틴을 실행(인터럽트 핸들러)
  - 인터럽트 서비스 루틴은 인터럽트가 발생했을 때의 대응 정보로 이루어진 프로그램
  - 즉, CPU는 인터럽트를 판단하고 서비스 루틴을 통해 처리하고 작업을 재개한다.

- 인터럽트 벡터 : 인터럽트 서비스 루틴 식별 정보
- CPU는 인터럽트 벡터를 통해 특정 인터럽트 서비스 루틴을 실행 가능


### 정리

### 명령어 사이클

인터럽트 사이클 : CPU가 현재 실행 중인 작업을 중단하고 인터럽트 신호에 따라 특수한 처리를 수행
  1. 인터럽트 요청 : 장치나 내부 이벤트가 인터럽트 발생
  2. 상태 저장 : 현재 작업을 스택에 저장
  3. 인터럽트 벡터 탐색 : 인터럽트 번호에 따라 ISR의 시작 주소를 탐색
  4. ISR 실행 : 해당 인터럽트에 대한 처리를 수행
  5. 복귀 : ISR 처리가 끝나면 저장된 작업을 복구하고 작업 재개

인출 사이클 : CPU가 실행할 명령어를 메모리로부터 읽어오는 과정
  1. 주소 지정 : 프로그램 카운터에 저장된 주소를 통해 다음 명령어의 위치를 결정
  2. 명령어 인출 : 해당 메모리 주소에서 명령어를 읽음
  3. 프로그램 카운터 증가 : 다음 명령어로 갱신

간접 사이클 : 간접 주소 지정 방식에서 사용되는 추가 사이클, 포인터를 통해 피연산자 주소를 인출
  1. 포인터 인출 : 명령어에 지정된 주소를 통해 피연산자의 주소를 읽어옴
  2. 주소 계산 : 명령어에 지정된 주소를 통하여 실제 데이터가 있는 메모리 위치를 탐색
  3. 메모리 접근 : 간접 주소가 가리키는 메모리 주소를 사용하여 데이터에 접근
  4. 명령어 실행 : 가져온 데이터를 이용해 연산 수행 또는 작업
  5. 결과 저장 : 메모리나 레지스터에 저장


##  명령어


### 고급 언어와 저급 언어
고급 언어는 사람이 컴퓨터에게 작성하기 편한 언어, 저급 언어는 컴퓨터가 읽기 편한 언어이다.
저급 언어에는 기계어와 어셈블리어가 있다.
고급 언어는 저급 언어로 변환되어서 전달되게 되는데, 이 과정에는 컴파일러와 인터프리터가 있다.

컴파일 언어는 소스 코드 전체를 한번에 변환 시키는데, 이 변환 과정을 컴파일이라고 한다.
컴파일이 수행되면 소스 코드가 저급 언어로 변환되는데, 변환된 코드를 목적 코드라고 한다.
단, 목적 코드는 바로 실행되지 않는다.

인터프리터 언어는 한 줄씩 변환하고 실행하는 언어로, 이 과정을 실행하는 도구를 인터프리터라고 한다.

두 언어의 차이는 변환을 하는 범위에서 발생하는데, 컴파일러의 경우 전체를 변환 시키기에
어느 한 곳에 오류가 발생하면 컴파일이 되지 않지만, 인터프리터는 해당 줄만 실행이 불가능하다.

목적 코드는 컴파일이 완료된 코드로, 목적 파일은 목적 코드가 모인 파일이다.
하지만 목적 파일은 바로 실행되지 않고 외부 기능과 연결하는 링킹 과정이 필요하다.
이 링킹 과정이 완료되어서야 실행 가능한 파일이 된다.


### 연산 코드와 오퍼랜드

저급 언어는 명령어로 이루어진 코드인데, 명령어는 다시 연산 코드와 오퍼랜드로 구성되어 있다.
연산 코드 : 명령어가 수행할 연산
오퍼랜드 : 연산에 사용할 데이터의 위치

- 즉시 주소 지정 방식
  - 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시
- 직접 주소 지정 방식
  - 유효 주소를 직접 명시
- 간접 주소 지정 방식
  - 유효 주소의 주소를 명시
- 레지스터 주소 지정 방식
  - 즉시 주소 지정 방식에서 데이터 대신 레지스터를 직접 명시
- 레지스터 간접 주소 지정 방식
  - 연산에 사용할 데이터를 메모리에 저장하고, 그 주소를 저장한 레지스터를 명시


차이
즉시 주소는 6비트 공간이 남는다면 최대 표현할 수 있는 값은 2^6
직접 주소는 16비트 메모리에 값이 담겨 있다면 최대 2^16, 단 주소의 범위는 2^6
간접 주소는 2^6 범위에 포인터 인덱스가 담겨있다.
포인터 테이블에는 각각의 메모리 주소를 가리키는 포인터들이 모여있는데,
해당 포인터의 주소는 포인터 테이블의 시작 주소 B + (포인터의 크기 * 포인터의 인덱스)로 나타내어진다.


### ALU

ALU는 레지스터를 통해 피연산자를 받아들이고, 제어장치로부터 수행할 연산에 대한 제어 신호를 받아들인다.
ALU는 연산을 수행하고 결과값과 플래그 레지스터를 내보낸다. (메모리에 저장하면 효율이 떨어지기에 우선 레지스터에 저장한다)
오버플로우 : 연산 결과가 담을 레지스터보다 큰 상황

ALU 내부 계산을 위한 회로
가산기, 보수기, 시프터, 오버플로우 검출기


### 제어장치

1. 클럭 신호를 받아들인다.
   - CPU 내의 모든 동작들은 일정한 주기에 맞춰서 실행된다.
   - 클럭은 일정한 간격의 펄스로 CPU의 각 구성 요소들이 언제 시작하고 끝낼지 알려주는 신호 역할을 한다.
   - 제어장치에서는 이 펄스에 맞춰서 작업을 순차적으로 실행하는데, 클럭 신호에 맞춰서 진행하기에 CPU 내부의 모든 작업이 동기화된다.
     - (각 부품들이 일정한 순서와 순서로 작동하게 된다)
2. 명령어 레지스터를 받아들인다.
   - 명령어 레지스터를 통해 명령어를 받고 해석하여 제어 신호를 발생시킨다.
3. 레지스터 속 플래그 값을 받아들인다.
   - 플래그 값을 받아들이고 참고하여 제어 신호를 발생시킨다.
4. 제어 버스로 전달된 제어 신호를 받아들인다.
   - 제어 신호는 외부 장치도 발생시킬 수 있는데, 이에 발생한 신호를 받아들인다.

제어장치는 CPU와 외부로 제어 신호를 내보낸다.
CPU 외부의 경우 제어 버스를 통하여 신호를 전달한다.
제어 신호는 값을 읽거나 쓰고 싶을 때 내보낸다.

CPU 내부에는 ALU와 레지스터로 제어 신호를 내보내는데,
ALU에는 수행할 연산을 지시하기 위해,
레지스터에는 저장된 명령어를 해석하거나 레지스터 간 데이터 이동을 위해 내보낸다.


### CPU 설계 기법

클럭 : 컴퓨터 부품들은 클럭 신호를 기준으로 실행하기에 클럭이 빠를수록 전체적으로 빨라진다.
(단, 일정 이상의 속도는 발열 문제가 발생하게 된다.)


코어와 멀티 코어
  - 오늘날 CPU는 명령어를 실행하는 부품을 여러 개 포함하는 부품으로 명칭이 확장되었다.
  - 코어를 여러 개 포함하고 있는 CPU를 멀티코어 CPU, 멀티코어 프로세서라고 부른다.
  - 코어가 늘어난다고 연산 처리 속도가 비례적으로 늘어나지 않는다.


스레드와 멀티스레드
  - 스레드 : 실행 흐름의 단위

1. 하드웨어적 스레드
  - 하나의 코어가 동시에 처리하는 명령어의 단위
  - 하나의 코어로 여러 명령어를 동시에 처리하는 CPU를 멀티스레드 프로세서 또는 멀티스레드 CPU라고 한다.
  - 하이퍼스레딩 : 인텔의 멀티스레드 기술

2. 소프트웨어적 스레드
  - 하나의 프로그램에서 독립적으로 실행하는 단위
  - 프로그램의 여러 부분이 동시에 실행될 수도 있다.
  

요약:
코어 - 로봇
스레드 - 로봇에 달린 팔
멀티코어 프로세서 - 로봇 세트
멀티스레드 프로세서 - 팔이 많은 로봇


### 명령어 파이프라인

1. 명령어 인출
2. 명령어 해석
3. 명령어 실행
4. 결과 저장

단계가 겹치지 않으면 동시에 실행 가능


파이프라인 위험
1. 데이터 위험 : 한 단계가 나머지에 의존적일 때 정상 작동 불가
2. 제어 위험 : 프로그램의 실행 흐름이 바뀔 때 미리 처리중인 명령어들이 무쓸모해짐(분기 예측으로 미리 해당 주소를 인출)
3. 구조적 위험 : 서로 다른 명령어가 같은 부품을 사용하려 할 때


슈퍼 스칼라 : 명령어 파이프라인이 여러 개인 구조

비순차적 명령어 처리 기법 : 데이터 의존성이 있을 때 순서에 무방한 명령어를 먼저 실행하고 처리하는 기법


### CISC와 RISC

ISA : CPU가 이해할 수 있는 명령어 집합 구조(CPU에 따라 다를 수 있음)
CISC : 복잡한 명령어 집합을 사용하는 컴퓨터
  - 형태와 크기가 다양한 가변 길이 명령어를 사용
  - 길이가 다양하기에 때로는 상대적으로 적은 수의 명령어로도 실행 가능
  - 일정하지 않기에 실행에 여러 클럭 주기가 필요(규격화되지 않았기에 파이프라인이 제대로 동작 X)
RISC : 짧고 규격화된 명령어, 1클럭 내외로 실행되는 명령어를 지향
  - 메모리 접근을 단순화, 최소화하는 대신 레지스터를 활용
  - 보다 많은 명령이 필요


### RAM의 특징과 종류

RAM : 휘발성, CPU가 실행할 프로그램을 저장(CPU는 보조기억장치에 접근 불가)
용량이 크면 실행할 프로그램들을 더 많이 저장할 수 있기에 메모리에 접근하는 시간을 줄일 수 있다.

DRAM : 저전력, 저렴, 높은 집적도
SRAM : 고전력, 비쌈, 낮은 집적도 - 캐시메모리용
SDRAM : DRAM에서 클럭 신호에 동기화 가능(클럭에 맞춘다는건 그만큼 실행이 빨라짐)
DDR SDRAM : SDRAM에서 대역폭을 넓힘(DDRn SDRAM은 n-1RAM보다 2배 빠름)


### 메모리의 주소 공간

물리 주소 : 메모리 하드웨어가 사용하는 주소
논리 주소 : CPU와 실행 중인 프로그램이 사용하는 주소

CPU는 논리 주소를 사용하며, 상호작용하려면 물리 주소와 논리 주소 간의 변환이 필요하다.

논리 주소와 물리 주소 간의 변환은 CPU와 주소 버스 사이의 MMU(메모리 관리 장치)를 통해 수행된다.

메모리 보호 기법 : 다른 프로그램의 영역을 침범할 수 있는 경우를 방지하기 위해 한계 레지스터가 보호한다.


### 캐시 메모리

CPU와 메모리 사이에 위치하고, 레지스터보다 용량이 크고 메모리가 빠른 SRAM 기반의 저장 장치

참조 지역성의 원리
- 공간 지역성 : 접근한 메모리 근처 공간을 접근하려는 경향
- 시간 지역성 : 최근에 접근했던 메모리 공간에 접근하려는 경향

캐시 히트 : 캐시 메모리에 필요한 데이터가 있는 상황
캐시 미스 : 캐시 메모리에 없고 메모리에 있는 상황
캐시 히트 횟수 : 히트 / 히트 + 미스


### 보조기억장치

하드디스크에서 데이터가 저장되는 곳은 원판인 플래터이다.

하드디스크는 자기적인 방식으로 저장하는데, 이 플래터를 회전시키는 구성 요소를 스핀들이라고 한다.
스핀들이 돌리는 속도는 RPM 단위로 표현한다.
플래터를 대상으로 읽고 쓰는 구성 요소는 헤드이다. (바늘)

플래터는 트랙과 섹터라는 단위로 데이터를 저장하는데, 동심원으로 나눴을 때 하나의 원을 트랙이라고 한다.
여러 겹의 플래터 상에서 같은 트랙이 위치한 곳을 모아 연결한 논리적 단위를 실린더라고 한다.